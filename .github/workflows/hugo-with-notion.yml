      # í–¥ìƒëœ ìŠ¤ë§ˆíŠ¸ ìºì‹œ + ì½˜í…ì¸  ë³µì› ì‹œìŠ¤í…œ
      - name: Enhanced Smart Cache with Content Restoration
        run: |
          echo "ğŸš€ Creating enhanced smart cached Notion sync script with content restoration..."
          cat > sync_notion.js << 'EOF'
          const { Client } = require('@notionhq/client');
          const fs = require('fs');
          const path = require('path');

          const notion = new Client({
            auth: process.env.NOTION_SECRET,
          });

          // ìºì‹œ íŒŒì¼ ê²½ë¡œ
          const CACHE_FILE = 'notion_cache.json';
          const CONTENT_BACKUP_FILE = 'content_backup.json';

          // ìºì‹œ ë¡œë“œ í•¨ìˆ˜
          function loadCache() {
            try {
              if (fs.existsSync(CACHE_FILE)) {
                const cacheData = fs.readFileSync(CACHE_FILE, 'utf8');
                return JSON.parse(cacheData);
              }
            } catch (error) {
              console.log('âš ï¸ Cache load error:', error.message);
            }
            return {};
          }

          // ì½˜í…ì¸  ë°±ì—… ë¡œë“œ í•¨ìˆ˜
          function loadContentBackup() {
            try {
              if (fs.existsSync(CONTENT_BACKUP_FILE)) {
                const backupData = fs.readFileSync(CONTENT_BACKUP_FILE, 'utf8');
                return JSON.parse(backupData);
              }
            } catch (error) {
              console.log('âš ï¸ Content backup load error:', error.message);
            }
            return {};
          }

          // ìºì‹œ ì €ì¥ í•¨ìˆ˜
          function saveCache(cache) {
            try {
              fs.writeFileSync(CACHE_FILE, JSON.stringify(cache, null, 2));
              console.log('ğŸ’¾ Cache saved successfully');
            } catch (error) {
              console.error('âŒ Cache save error:', error.message);
            }
          }

          // ì½˜í…ì¸  ë°±ì—… ì €ì¥ í•¨ìˆ˜
          function saveContentBackup(backup) {
            try {
              fs.writeFileSync(CONTENT_BACKUP_FILE, JSON.stringify(backup, null, 2));
              console.log('ğŸ“¦ Content backup saved successfully');
            } catch (error) {
              console.error('âŒ Content backup save error:', error.message);
            }
          }

          // ê¸°ì¡´ í•¨ìˆ˜ë“¤ (createSafeYamlString, formatDate, createSlug, convertRichText, convertBlocks, getAllPages)ì€ ë™ì¼
          function createSafeYamlString(str) {
            if (!str) return '""';
            const escaped = str
              .replace(/\\\\/g, '\\\\\\\\')
              .replace(/"/g, '\\\\"')
              .replace(/\\n/g, '\\\\n')
              .replace(/\\r/g, '\\\\r')
              .replace(/\\t/g, '\\\\t');
            return `"${escaped}"`;
          }

          function formatDate(dateString) {
            if (!dateString) return new Date().toISOString();
            const date = new Date(dateString);
            return date.toISOString();
          }

          function createSlug(title) {
            return title
              .toLowerCase()
              .replace(/[^a-z0-9ê°€-í£\\s]/g, '')
              .replace(/\\s+/g, '-')
              .replace(/-+/g, '-')
              .replace(/^-|-$/g, '')
              .substring(0, 100);
          }

          function convertRichText(richTextArray) {
            if (!richTextArray || !Array.isArray(richTextArray)) return '';
            return richTextArray.map(textObj => {
              let text = textObj.plain_text || '';
              if (textObj.annotations?.bold) text = `**${text}**`;
              if (textObj.annotations?.italic) text = `*${text}*`;
              if (textObj.annotations?.code) text = '`' + text + '`';
              if (textObj.annotations?.strikethrough) text = `~~${text}~~`;
              if (textObj.annotations?.underline) text = `<u>${text}</u>`;
              if (textObj.href) text = `[${text}](${textObj.href})`;
              return text;
            }).join('');
          }

          async function convertBlocks(pageId, depth = 0) {
            try {
              const blocks = await notion.blocks.children.list({
                block_id: pageId,
                page_size: 100
              });

              let content = '';
              const indent = '  '.repeat(depth);

              for (const block of blocks.results) {
                switch (block.type) {
                  case 'paragraph':
                    if (block.paragraph?.rich_text?.length > 0) {
                      content += indent + convertRichText(block.paragraph.rich_text) + '\\n\\n';
                    } else if (block.paragraph?.rich_text?.length === 0) {
                      content += '\\n';
                    }
                    break;

                  case 'heading_1':
                    if (block.heading_1?.rich_text?.length > 0) {
                      content += indent + '# ' + convertRichText(block.heading_1.rich_text) + '\\n\\n';
                    }
                    break;

                  case 'heading_2':
                    if (block.heading_2?.rich_text?.length > 0) {
                      content += indent + '## ' + convertRichText(block.heading_2.rich_text) + '\\n\\n';
                    }
                    break;

                  case 'heading_3':
                    if (block.heading_3?.rich_text?.length > 0) {
                      content += indent + '### ' + convertRichText(block.heading_3.rich_text) + '\\n\\n';
                    }
                    break;

                  case 'bulleted_list_item':
                    if (block.bulleted_list_item?.rich_text?.length > 0) {
                      content += indent + '- ' + convertRichText(block.bulleted_list_item.rich_text) + '\\n';
                      if (block.has_children) {
                        const childContent = await convertBlocks(block.id, depth + 1);
                        content += childContent;
                      }
                    }
                    break;

                  case 'numbered_list_item':
                    if (block.numbered_list_item?.rich_text?.length > 0) {
                      content += indent + '1. ' + convertRichText(block.numbered_list_item.rich_text) + '\\n';
                      if (block.has_children) {
                        const childContent = await convertBlocks(block.id, depth + 1);
                        content += childContent;
                      }
                    }
                    break;

                  case 'toggle':
                    if (block.toggle?.rich_text?.length > 0) {
                      const toggleTitle = convertRichText(block.toggle.rich_text);
                      content += indent + '<details>\\n' + indent + '<summary>' + toggleTitle + '</summary>\\n\\n';
                      if (block.has_children) {
                        const childContent = await convertBlocks(block.id, depth);
                        content += childContent;
                      }
                      content += indent + '</details>\\n\\n';
                    }
                    break;

                  case 'code':
                    if (block.code?.rich_text?.length > 0) {
                      const language = block.code.language || '';
                      const codeText = convertRichText(block.code.rich_text);
                      content += indent + '```' + language + '\\n' + codeText + '\\n```\\n\\n';
                    }
                    break;

                  case 'quote':
                    if (block.quote?.rich_text?.length > 0) {
                      content += indent + '> ' + convertRichText(block.quote.rich_text) + '\\n\\n';
                    }
                    break;

                  case 'callout':
                    if (block.callout?.rich_text?.length > 0) {
                      const icon = block.callout.icon?.emoji || '';
                      const calloutText = convertRichText(block.callout.rich_text);
                      content += indent + '> ' + icon + ' **' + calloutText + '**\\n\\n';
                    }
                    break;

                  case 'divider':
                    content += indent + '---\\n\\n';
                    break;

                  case 'image':
                    if (block.image?.file?.url) {
                      const caption = block.image.caption?.length > 0 ?
                        convertRichText(block.image.caption) : 'Image';
                      content += indent + '![' + caption + '](' + block.image.file.url + ')\\n\\n';
                    } else if (block.image?.external?.url) {
                      const caption = block.image.caption?.length > 0 ?
                        convertRichText(block.image.caption) : 'Image';
                      content += indent + '![' + caption + '](' + block.image.external.url + ')\\n\\n';
                    }
                    break;

                  case 'video':
                    if (block.video?.external?.url) {
                      const url = block.video.external.url;
                      if (url.includes('youtube.com') || url.includes('youtu.be')) {
                        content += indent + '[YouTube ë™ì˜ìƒ ë³´ê¸°](' + url + ')\\n\\n';
                      } else {
                        content += indent + '[ë™ì˜ìƒ ë³´ê¸°](' + url + ')\\n\\n';
                      }
                    }
                    break;

                  case 'bookmark':
                  case 'link_preview':
                    const bookmarkUrl = block.bookmark?.url || block.link_preview?.url;
                    if (bookmarkUrl) {
                      const title = block.bookmark?.caption?.length > 0 ?
                        convertRichText(block.bookmark.caption) : bookmarkUrl;
                      content += indent + '[' + title + '](' + bookmarkUrl + ')\\n\\n';
                    }
                    break;

                  case 'embed':
                    if (block.embed?.url) {
                      content += indent + '[ì„ë² ë“œ ì½˜í…ì¸ ](' + block.embed.url + ')\\n\\n';
                    }
                    break;

                  case 'file':
                    if (block.file?.file?.url) {
                      const fileName = block.file.name || 'File';
                      content += indent + '[' + fileName + '](' + block.file.file.url + ')\\n\\n';
                    }
                    break;

                  case 'pdf':
                    if (block.pdf?.file?.url) {
                      content += indent + '[PDF ë¬¸ì„œ](' + block.pdf.file.url + ')\\n\\n';
                    }
                    break;

                  case 'table':
                    if (block.has_children) {
                      content += indent + '\\n| | |\\n|---|---|\\n';
                      const tableContent = await convertBlocks(block.id, depth);
                      content += tableContent + '\\n';
                    }
                    break;

                  case 'table_row':
                    if (block.table_row?.cells?.length > 0) {
                      const cells = block.table_row.cells.map(cell =>
                        convertRichText(cell) || ' '
                      );
                      content += indent + '| ' + cells.join(' | ') + ' |\\n';
                    }
                    break;

                  case 'to_do':
                    if (block.to_do?.rich_text?.length > 0) {
                      const checked = block.to_do.checked ? '[x]' : '[ ]';
                      content += indent + '- ' + checked + ' ' + convertRichText(block.to_do.rich_text) + '\\n';
                    }
                    break;

                  case 'column_list':
                    if (block.has_children) {
                      content += indent + '<div class="columns">\\n';
                      const columnContent = await convertBlocks(block.id, depth);
                      content += columnContent;
                      content += indent + '</div>\\n\\n';
                    }
                    break;

                  case 'column':
                    if (block.has_children) {
                      content += indent + '<div class="column">\\n';
                      const columnContent = await convertBlocks(block.id, depth);
                      content += columnContent;
                      content += indent + '</div>\\n';
                    }
                    break;
                }

                await new Promise(resolve => setTimeout(resolve, 20));
              }

              return content;
            } catch (error) {
              console.error('âŒ Error converting blocks: ' + error.message);
              return '';
            }
          }

          async function getAllPages() {
            let allPages = [];
            let hasMore = true;
            let nextCursor = undefined;

            while (hasMore) {
              try {
                const response = await notion.databases.query({
                  database_id: process.env.DATABASE_ID,
                  filter: {
                    property: 'Status',
                    select: {
                      equals: 'Published'
                    }
                  },
                  sorts: [
                    {
                      property: 'Date',
                      direction: 'descending'
                    }
                  ],
                  start_cursor: nextCursor,
                  page_size: 100
                });

                allPages = allPages.concat(response.results);
                hasMore = response.has_more;
                nextCursor = response.next_cursor;

                console.log('ğŸ“„ Retrieved ' + response.results.length + ' pages (Total: ' + allPages.length + ')');

                if (hasMore) {
                  await new Promise(resolve => setTimeout(resolve, 50));
                }

              } catch (error) {
                console.error('âŒ Error fetching pages: ' + error.message);
                break;
              }
            }

            return allPages;
          }

          async function syncNotionDatabase() {
            try {
              console.log('ğŸ”„ Connecting to Notion...');

              // ìºì‹œ ë° ë°±ì—… ë¡œë“œ
              const cache = loadCache();
              const contentBackup = loadContentBackup();
              console.log('ğŸ“‹ Loaded cache with ' + Object.keys(cache).length + ' entries');
              console.log('ğŸ“¦ Loaded content backup with ' + Object.keys(contentBackup).length + ' entries');

              const allPages = await getAllPages();
              console.log('ğŸ“Š Found ' + allPages.length + ' published posts');

              if (!fs.existsSync('content/posts')) {
                fs.mkdirSync('content/posts', { recursive: true });
              }

              let successCount = 0;
              let errorCount = 0;
              let skippedCount = 0;
              let restoredCount = 0;
              let updatedCount = 0;
              const newCache = {};
              const newBackup = {};

              for (const page of allPages) {
                try {
                  const pageId = page.id;
                  const lastEditedTime = page.last_edited_time;
                  const title = page.properties['ì œëª©']?.title?.[0]?.plain_text || 'Untitled';
                  const slug = createSlug(title);

                  // ìºì‹œ í™•ì¸ - ë³€ê²½ì‚¬í•­ì´ ì—†ìœ¼ë©´ ë°±ì—…ì—ì„œ ë³µì›
                  if (cache[pageId] && cache[pageId].last_edited_time === lastEditedTime) {
                    console.log('â© Skipped (no changes): "' + title + '"');
                    
                    // ìºì‹œ ì •ë³´ ìœ ì§€
                    newCache[pageId] = cache[pageId];
                    
                    // ë°±ì—…ì—ì„œ ì½˜í…ì¸  ë³µì›
                    if (contentBackup[pageId] && contentBackup[pageId].content) {
                      const postDir = 'content/posts/' + slug;
                      if (!fs.existsSync(postDir)) {
                        fs.mkdirSync(postDir, { recursive: true });
                      }
                      
                      fs.writeFileSync(postDir + '/index.md', contentBackup[pageId].content, 'utf8');
                      newBackup[pageId] = contentBackup[pageId];
                      
                      console.log('ğŸ“¥ Restored from backup: "' + title + '" â†’ ' + slug);
                      restoredCount++;
                    } else {
                      console.log('âš ï¸ No backup found for: "' + title + '"');
                    }
                    
                    skippedCount++;
                    continue;
                  }

                  console.log('ğŸ”„ Processing: "' + title + '" (last edited: ' + lastEditedTime + ')');

                  const dateValue = page.properties['Date']?.date?.start || page.created_time;
                  const tags = page.properties['Tags']?.multi_select?.map(tag => tag.name) || [];
                  const themes = page.properties['Thems']?.multi_select?.map(theme => theme.name) || [];
                  const aiSummary = page.properties['AI ìš”ì•½']?.rich_text?.[0]?.plain_text || '';

                  const blockContent = await convertBlocks(page.id);

                  let content = '---\\n';
                  content += 'title: ' + createSafeYamlString(title) + '\\n';
                  content += 'date: ' + formatDate(dateValue) + '\\n';
                  content += 'draft: false\\n';

                  if (tags.length > 0 || themes.length > 0) {
                    const allTags = [...tags, ...themes].map(tag => createSafeYamlString(tag));
                    content += 'tags: [' + allTags.join(', ') + ']\\n';
                  }

                  if (themes.length > 0) {
                    const categories = themes.map(theme => createSafeYamlString(theme));
                    content += 'categories: [' + categories.join(', ') + ']\\n';
                  }

                  if (aiSummary) {
                    const truncatedSummary = aiSummary.length > 50 ?
                      aiSummary.substring(0, 50) + '...' : aiSummary;
                    content += 'description: ' + createSafeYamlString(truncatedSummary) + '\\n';
                  }

                  content += 'notion_id: ' + createSafeYamlString(page.id) + '\\n';
                  content += 'notion_url: ' + createSafeYamlString(page.url) + '\\n';
                  content += '---\\n\\n';

                  if (blockContent.trim()) {
                    content += blockContent;
                  } else {
                    content += '# ' + title + '\\n\\n*ì´ ê¸€ì€ Notionì—ì„œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤.*\\n\\n';
                    content += '[ì›ë³¸ ë³´ê¸°](' + page.url + ')\\n';
                  }

                  const postDir = 'content/posts/' + slug;
                  if (!fs.existsSync(postDir)) {
                    fs.mkdirSync(postDir, { recursive: true });
                  }

                  fs.writeFileSync(postDir + '/index.md', content, 'utf8');

                  // ìºì‹œì— ì •ë³´ ì €ì¥
                  newCache[pageId] = {
                    last_edited_time: lastEditedTime,
                    title: title,
                    slug: slug,
                    processed_at: new Date().toISOString()
                  };

                  // ë°±ì—…ì— ì½˜í…ì¸  ì €ì¥
                  newBackup[pageId] = {
                    title: title,
                    slug: slug,
                    content: content,
                    backed_up_at: new Date().toISOString()
                  };

                  if (cache[pageId]) {
                    console.log('ğŸ”„ Updated: "' + title + '" â†’ ' + slug);
                    updatedCount++;
                  } else {
                    console.log('âœ… Created: "' + title + '" â†’ ' + slug);
                  }

                  successCount++;

                  await new Promise(resolve => setTimeout(resolve, 50));

                } catch (err) {
                  console.error('âŒ Error processing page: ' + err.message);
                  errorCount++;
                }
              }

              // ìƒˆ ìºì‹œ ë° ë°±ì—… ì €ì¥
              saveCache(newCache);
              saveContentBackup(newBackup);

              console.log('\\nğŸ“Š ë™ê¸°í™” ì™„ë£Œ:');
              console.log('âœ… ì„±ê³µ: ' + successCount + 'ê°œ');
              console.log('ğŸ”„ ì—…ë°ì´íŠ¸: ' + updatedCount + 'ê°œ');
              console.log('ğŸ“¥ ë³µì›: ' + restoredCount + 'ê°œ');
              console.log('â© ìŠ¤í‚µ: ' + skippedCount + 'ê°œ');
              console.log('âŒ ì‹¤íŒ¨: ' + errorCount + 'ê°œ');
              console.log('âš¡ ìºì‹œ íš¨ìœ¨: ' + Math.round((skippedCount / allPages.length) * 100) + '%');

            } catch (error) {
              console.error('âŒ Notion API Error: ' + error.message);
              process.exit(0);
            }
          }

          syncNotionDatabase();
          EOF

          npm init -y
          npm install @notionhq/client

          NOTION_SECRET="${{ secrets.NOTION_SECRET }}" DATABASE_ID="${{ secrets.DATABASE_ID }}" node sync_notion.js

      # í–¥ìƒëœ ìºì‹œ íŒŒì¼ ì»¤ë°‹ (ë°±ì—… í¬í•¨)
      - name: Commit Enhanced Cache and Backup
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if [ -f notion_cache.json ] || [ -f content_backup.json ]; then
            git add notion_cache.json content_backup.json
            if git diff --staged --quiet; then
              echo "No cache or backup changes to commit"
            else
              git commit -m "Update Notion cache and content backup [skip ci]" || echo "No changes to commit"
              git push || echo "No changes to push"
            fi
          fi

      - name: Enhanced Sync Results Report
        run: |
          echo "ğŸ“Š í–¥ìƒëœ ë™ê¸°í™” ê²°ê³¼:"
          echo "=== ìƒì„±ëœ í¬ìŠ¤íŠ¸ ==="
          TOTAL_POSTS=$(find content/posts -name "*.md" -type f | wc -l)
          echo "${TOTAL_POSTS}ê°œì˜ í¬ìŠ¤íŠ¸ê°€ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤."

          echo "=== ìºì‹œ ë° ë°±ì—… ì •ë³´ ==="
          if [ -f notion_cache.json ]; then
            CACHE_LINES=$(wc -l < notion_cache.json)
            echo "ìºì‹œ íŒŒì¼: ${CACHE_LINES} ë¼ì¸"
          fi
          
          if [ -f content_backup.json ]; then
            BACKUP_LINES=$(wc -l < content_backup.json)
            echo "ë°±ì—… íŒŒì¼: ${BACKUP_LINES} ë¼ì¸"
          fi

          echo "=== ìµœê·¼ í¬ìŠ¤íŠ¸ ëª©ë¡ ==="
          find content/posts -name "index.md" -type f | head -5

          if [ "$TOTAL_POSTS" -eq 0 ]; then
            echo "âš ï¸ ê²½ê³ : í¬ìŠ¤íŠ¸ê°€ 0ê°œì…ë‹ˆë‹¤. ë°±ì—… ë³µì› ì‹¤íŒ¨ ê°€ëŠ¥ì„± ìˆìŒ"
            exit 1
          else
            echo "âœ… ì„±ê³µ: ${TOTAL_POSTS}ê°œ í¬ìŠ¤íŠ¸ ì¤€ë¹„ ì™„ë£Œ"
          fi
