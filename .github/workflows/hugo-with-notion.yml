name: Hugo with Direct Notion API

on:
  push:
    branches: ["main"]
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0

      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Hugo
        uses: peaceiris/actions-hugo@v3
        with:
          hugo-version: 'latest'
          extended: true

      # ðŸ› ï¸ ì™„ì „ížˆ ìˆ˜ì •ëœ ì•ˆì „í•œ Notion ë™ê¸°í™” ìŠ¤í¬ë¦½íŠ¸
      - name: Safe Notion Sync Script
        run: |
          echo "Creating safe Notion sync script..."
          cat > sync_notion.js << 'EOF'
          const { Client } = require('@notionhq/client');
          const fs = require('fs');

          const notion = new Client({ auth: process.env.NOTION_SECRET });
          const CACHE_FILE = 'notion_cache.json';

          function loadCache() {
            try {
              if (fs.existsSync(CACHE_FILE)) {
                return JSON.parse(fs.readFileSync(CACHE_FILE, 'utf8'));
              }
            } catch (error) {
              console.log('Cache load error:', error.message);
            }
            return {};
          }

          function saveCache(cache) {
            try {
              fs.writeFileSync(CACHE_FILE, JSON.stringify(cache, null, 2));
              console.log('Cache saved successfully');
            } catch (error) {
              console.error('Cache save error:', error.message);
            }
          }

          function createSafeYamlString(str) {
            if (!str) return '""';
            
            // ìœ„í—˜í•œ ë¬¸ìžë“¤ì„ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
            let safe = str
              .replace(/\\/g, '\\\\')    // ë°±ìŠ¬ëž˜ì‹œ
              .replace(/"/g, '\\"')      // ë”°ì˜´í‘œ
              .replace(/\n/g, ' ')       // ì¤„ë°”ê¿ˆ -> ìŠ¤íŽ˜ì´ìŠ¤
              .replace(/\r/g, ' ')       // ìºë¦¬ì§€ ë¦¬í„´ -> ìŠ¤íŽ˜ì´ìŠ¤
              .replace(/\t/g, ' ')       // íƒ­ -> ìŠ¤íŽ˜ì´ìŠ¤
              .replace(/[\x00-\x1f\x7f-\x9f]/g, ''); // ì œì–´ ë¬¸ìž ì œê±°
            
            return `"${safe}"`;
          }

          function formatDate(dateString) {
            if (!dateString) return new Date().toISOString();
            return new Date(dateString).toISOString();
          }

          function createSlug(title) {
            return title
              .toLowerCase()
              .replace(/[^a-z0-9ê°€-íž£\s]/g, '')
              .replace(/\s+/g, '-')
              .replace(/-+/g, '-')
              .replace(/^-|-$/g, '')
              .substring(0, 100);
          }

          function convertRichText(richTextArray) {
            if (!richTextArray || !Array.isArray(richTextArray)) return '';
            return richTextArray.map(textObj => {
              let text = textObj.plain_text || '';
              if (textObj.annotations?.bold) text = `**${text}**`;
              if (textObj.annotations?.italic) text = `*${text}*`;
              if (textObj.annotations?.code) text = '`' + text + '`';
              if (textObj.annotations?.strikethrough) text = `~~${text}~~`;
              if (textObj.annotations?.underline) text = `<u>${text}</u>`;
              if (textObj.href) text = `[${text}](${textObj.href})`;
              return text;
            }).join('');
          }

          async function convertBlocks(pageId) {
            try {
              const blocks = await notion.blocks.children.list({
                block_id: pageId,
                page_size: 100
              });

              let content = '';
              for (const block of blocks.results) {
                switch (block.type) {
                  case 'paragraph':
                    if (block.paragraph?.rich_text?.length > 0) {
                      content += convertRichText(block.paragraph.rich_text) + '\n\n';
                    } else {
                      content += '\n';
                    }
                    break;
                    
                  case 'heading_1':
                    if (block.heading_1?.rich_text?.length > 0) {
                      content += '# ' + convertRichText(block.heading_1.rich_text) + '\n\n';
                    }
                    break;
                    
                  case 'heading_2':
                    if (block.heading_2?.rich_text?.length > 0) {
                      content += '## ' + convertRichText(block.heading_2.rich_text) + '\n\n';
                    }
                    break;
                    
                  case 'heading_3':
                    if (block.heading_3?.rich_text?.length > 0) {
                      content += '### ' + convertRichText(block.heading_3.rich_text) + '\n\n';
                    }
                    break;
                    
                  case 'bulleted_list_item':
                    if (block.bulleted_list_item?.rich_text?.length > 0) {
                      content += '- ' + convertRichText(block.bulleted_list_item.rich_text) + '\n';
                    }
                    break;
                    
                  case 'numbered_list_item':
                    if (block.numbered_list_item?.rich_text?.length > 0) {
                      content += '1. ' + convertRichText(block.numbered_list_item.rich_text) + '\n';
                    }
                    break;
                    
                  case 'code':
                    if (block.code?.rich_text?.length > 0) {
                      const language = block.code.language || '';
                      const codeText = convertRichText(block.code.rich_text);
                      content += '```' + language + '\n' + codeText + '\n```\n\n';
                    }
                    break;
                    
                  case 'quote':
                    if (block.quote?.rich_text?.length > 0) {
                      content += '> ' + convertRichText(block.quote.rich_text) + '\n\n';
                    }
                    break;
                    
                  case 'callout':
                    if (block.callout?.rich_text?.length > 0) {
                      const icon = block.callout.icon?.emoji || 'ðŸ’¡';
                      const calloutText = convertRichText(block.callout.rich_text);
                      content += '> ' + icon + ' **' + calloutText + '**\n\n';
                    }
                    break;
                    
                  case 'divider':
                    content += '---\n\n';
                    break;
                    
                  case 'image':
                    if (block.image?.file?.url) {
                      content += '![Image](' + block.image.file.url + ')\n\n';
                    } else if (block.image?.external?.url) {
                      content += '![Image](' + block.image.external.url + ')\n\n';
                    }
                    break;
                }
                
                await new Promise(resolve => setTimeout(resolve, 20));
              }
              
              return content;
            } catch (error) {
              console.error('Error converting blocks:', error.message);
              return '';
            }
          }

          async function getAllPages() {
            let allPages = [];
            let hasMore = true;
            let nextCursor = undefined;

            while (hasMore) {
              try {
                const response = await notion.databases.query({
                  database_id: process.env.DATABASE_ID,
                  filter: {
                    property: 'Status',
                    select: { equals: 'Published' }
                  },
                  sorts: [{ property: 'Date', direction: 'descending' }],
                  start_cursor: nextCursor,
                  page_size: 100
                });

                allPages = allPages.concat(response.results);
                hasMore = response.has_more;
                nextCursor = response.next_cursor;

                console.log('Retrieved', response.results.length, 'pages (Total:', allPages.length + ')');
                
                if (hasMore) {
                  await new Promise(resolve => setTimeout(resolve, 50));
                }
              } catch (error) {
                console.error('Error fetching pages:', error.message);
                break;
              }
            }
            return allPages;
          }

          async function syncNotionDatabase() {
            try {
              console.log('Connecting to Notion...');
              
              const cache = loadCache();
              console.log('Loaded cache with', Object.keys(cache).length, 'entries');
              
              const allPages = await getAllPages();
              console.log('Found', allPages.length, 'published posts');

              if (!fs.existsSync('content/posts')) {
                fs.mkdirSync('content/posts', { recursive: true });
              }

              let successCount = 0;
              let skippedCount = 0;
              let updatedCount = 0;
              const newCache = {};

              for (const page of allPages) {
                try {
                  const pageId = page.id;
                  const lastEditedTime = page.last_edited_time;
                  const title = page.properties['ì œëª©']?.title?.[0]?.plain_text || 'Untitled';
                  const slug = createSlug(title);
                  const postDir = 'content/posts/' + slug;
                  const postFile = postDir + '/index.md';

                  // ìºì‹œ + íŒŒì¼ ì¡´ìž¬ í™•ì¸
                  if (cache[pageId] && 
                      cache[pageId].last_edited_time === lastEditedTime && 
                      fs.existsSync(postFile)) {
                    console.log('Skipped (no changes):', title);
                    newCache[pageId] = cache[pageId];
                    skippedCount++;
                    continue;
                  }

                  console.log('Processing:', title);

                  const dateValue = page.properties['Date']?.date?.start || page.created_time;
                  const tags = page.properties['Tags']?.multi_select?.map(tag => tag.name) || [];
                  const themes = page.properties['Thems']?.multi_select?.map(theme => theme.name) || [];
                  const aiSummary = page.properties['AI ìš”ì•½']?.rich_text?.[0]?.plain_text || '';

                  const blockContent = await convertBlocks(page.id);

                  // YAML Front Matter ìƒì„± - ì•ˆì „í•œ ë°©ë²•
                  let frontMatter = '---\n';
                  frontMatter += 'title: ' + createSafeYamlString(title) + '\n';
                  frontMatter += 'date: ' + formatDate(dateValue) + '\n';
                  frontMatter += 'draft: false\n';

                  if (tags.length > 0 || themes.length > 0) {
                    const allTags = [...tags, ...themes].map(tag => createSafeYamlString(tag));
                    frontMatter += 'tags: [' + allTags.join(', ') + ']\n';
                  }

                  if (themes.length > 0) {
                    const categories = themes.map(theme => createSafeYamlString(theme));
                    frontMatter += 'categories: [' + categories.join(', ') + ']\n';
                  }

                  if (aiSummary) {
                    const truncatedSummary = aiSummary.length > 50 ? 
                      aiSummary.substring(0, 50) + '...' : aiSummary;
                    frontMatter += 'description: ' + createSafeYamlString(truncatedSummary) + '\n';
                  }

                  frontMatter += 'notion_id: ' + createSafeYamlString(page.id) + '\n';
                  frontMatter += 'notion_url: ' + createSafeYamlString(page.url) + '\n';
                  frontMatter += '---\n\n';

                  // ë³¸ë¬¸ ë‚´ìš©
                  let mainContent;
                  if (blockContent.trim()) {
                    mainContent = blockContent;
                  } else {
                    mainContent = '# ' + title + '\n\n*ì´ ê¸€ì€ Notionì—ì„œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤.*\n\n[ì›ë³¸ ë³´ê¸°](' + page.url + ')\n';
                  }

                  const fullContent = frontMatter + mainContent;

                  if (!fs.existsSync(postDir)) {
                    fs.mkdirSync(postDir, { recursive: true });
                  }

                  fs.writeFileSync(postFile, fullContent, 'utf8');

                  newCache[pageId] = {
                    last_edited_time: lastEditedTime,
                    title: title,
                    slug: slug,
                    processed_at: new Date().toISOString()
                  };

                  if (cache[pageId]) {
                    console.log('Updated:', title, 'â†’', slug);
                    updatedCount++;
                  } else {
                    console.log('Created:', title, 'â†’', slug);
                  }

                  successCount++;
                  await new Promise(resolve => setTimeout(resolve, 50));

                } catch (err) {
                  console.error('Error processing page:', err.message);
                }
              }

              saveCache(newCache);

              console.log('\në™ê¸°í™” ì™„ë£Œ:');
              console.log('ì„±ê³µ:', successCount + 'ê°œ');
              console.log('ì—…ë°ì´íŠ¸:', updatedCount + 'ê°œ');
              console.log('ìŠ¤í‚µ:', skippedCount + 'ê°œ');
              console.log('ìºì‹œ íš¨ìœ¨:', Math.round((skippedCount / allPages.length) * 100) + '%');

            } catch (error) {
              console.error('Notion API Error:', error.message);
              process.exit(0);
            }
          }

          syncNotionDatabase();
          EOF

          npm init -y
          npm install @notionhq/client

          NOTION_SECRET="${{ secrets.NOTION_SECRET }}" DATABASE_ID="${{ secrets.DATABASE_ID }}" node sync_notion.js

      # ìºì‹œ ì»¤ë°‹
      - name: Commit Cache
        run: |
          if [ -f notion_cache.json ]; then
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git add notion_cache.json
            if git diff --staged --quiet; then
              echo "No cache changes to commit"
            else
              git commit -m "Update Notion cache [skip ci]" || echo "No changes to commit"
              git push || echo "No changes to push"
            fi
          fi

      # ë””ë²„ê¹…ì„ ìœ„í•œ íŒŒì¼ ë‚´ìš© í™•ì¸
      - name: Debug YAML Issues
        run: |
          echo "=== ë¬¸ì œê°€ ëœ íŒŒì¼ í™•ì¸ ==="
          problematic_file=$(find content/posts -name "index.md" | head -1)
          if [ -f "$problematic_file" ]; then
            echo "íŒŒì¼ ê²½ë¡œ: $problematic_file"
            echo "--- íŒŒì¼ ë‚´ìš© ì‹œìž‘ ---"
            head -20 "$problematic_file"
            echo "--- íŒŒì¼ ë‚´ìš© ë ---"
            echo "--- YAML ê²€ì¦ ---"
            head -10 "$problematic_file" | grep -E '^(---|[^:]+:)'
          fi

      - name: Ensure Default Content
        run: |
          mkdir -p content
          cat > content/_index.md << 'EOF'
          ---
          title: "ì‚½ì§ˆ ì €ìž¥ì†Œ"
          ---

          ê°œë°œìž Cybechoì˜ ì‚½ì§ˆê³¼ í•™ìŠµì„ ê¸°ë¡í•˜ëŠ” ê³µê°„ìž…ë‹ˆë‹¤.

          ì‹¤íŒ¨ì—ì„œ ë°°ìš°ê³ , ì„±ê³µì„ ê¸°ë¡í•˜ë©°, ì§€ì‹ì„ ê³µìœ í•©ë‹ˆë‹¤.
          EOF

      - name: Build with Hugo
        env:
          HUGO_ENVIRONMENT: production
        run: |
          echo "Building Hugo site..."
          hugo --gc --minify

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./public

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
