---
title: "세션(Session)이 과부하를 일으키는 이유"
date: 2025-03-18T09:57:00.000Z
draft: false
tags: ["Infra"]
series: ["Infra & Network"]
description: "세션이 과부하를 일으키는 주요 원인은 사용자 수 증가로 인한 메모리 부담, 세션 동기화 문제, 빈번한 읽기/쓰기 요청이다. 온라인 게임에서는 실시간 사용자 상태 관리와 동시 접속자 수가 많아 세션 유지가 복잡해지며, 애플리케이션 레이어와 데이터 레이어에서 과부하가 발생한다. 효율적인 세션 관리를 위해 부하 분산, 세션 스케일링, 성능 모니터링 등의 최적화 기법이 필요하다."
notion_id: "1ba1bab9-e3f8-8048-aac6-c97910e44a3d"
notion_url: "https://www.notion.so/Session-1ba1bab9e3f88048aac6c97910e44a3d"
---

# 세션(Session)이 과부하를 일으키는 이유

> **Summary**
> 세션이 과부하를 일으키는 주요 원인은 사용자 수 증가로 인한 메모리 부담, 세션 동기화 문제, 빈번한 읽기/쓰기 요청이다. 온라인 게임에서는 실시간 사용자 상태 관리와 동시 접속자 수가 많아 세션 유지가 복잡해지며, 애플리케이션 레이어와 데이터 레이어에서 과부하가 발생한다. 효율적인 세션 관리를 위해 부하 분산, 세션 스케일링, 성능 모니터링 등의 최적화 기법이 필요하다.

---

아래 글은 세션(Session)이 왜 과부하를 일으키는지, 온라인 게임 환경에서 세션 유지가 어떤 의미로 관련이 있는지, 그리고 어느 레이어(layer)에서 주로 이러한 과부하가 발생하는지를 설명합니다.

---

## 1. 세션(Session)이 과부하를 일으키는 이유

1. **사용자 수 증가에 따른 메모리 부담**
  - 세션은 일반적으로 사용자별 상태나 정보를 **서버가 저장**하고 관리해야 합니다.
  - 사용자 수가 늘면 세션 정보를 담고 있는 저장소(서버 메모리나 Redis 같은 외부 스토어)에서도 **관리해야 할 데이터가 기하급수적으로 많아집**니다.
  - 이는 서버 혹은 세션 스토어가 감당해야 하는 **메모리 사용량**과 **처리량**을 크게 늘려 과부하로 이어집니다.
1. **세션 동기화 문제**
  - 서버가 여러 대 있을 때, 모든 서버가 동일한 세션 상태를 유지하려면 **세션 동기화(Replication)** 또는 **공용 스토어(예: Redis)**가 필요합니다.
  - 이 과정에서 **추가적인 네트워크 오버헤드**가 발생하고, 세션 읽기/쓰기에 지연이 생길 수 있습니다.
1. **빈번한 읽기/쓰기 요청**
  - 세션은 사용자 요청이 있을 때마다 갱신되거나 조회되는 일이 많습니다(로그인 상태, 장바구니, 포인트 적립 등).
  - 이러한 **고빈도 읽기/쓰기**가 누적되면 서버나 세션 스토어(Redis, DB)가 커다란 부하를 받게 됩니다.
---

## 2. 온라인 게임과 세션 유지의 연관성

1. **실시간 사용자 상태 관리**
  - 온라인 게임에서는 단순 로그인 상태뿐 아니라, 게임 진행 상황(HP, 아이템, 레벨, 위치 등)까지 **사용자 상태가 실시간**으로 변합니다.
  - 이런 정보를 세션에 저장하거나 세션과 유사한 형태(예: 게임 서버 메모리에 사용자 상태를 유지)로 관리할 경우, **사용자 수 × 실시간 업데이트 양**이 곧바로 서버 부하로 이어집니다.
1. **지속 연결(또는 빠른 재접속) 보장**
  - 온라인 게임은 플레이 중 연결이 끊겨도 **곧바로 재접속**할 수 있는 환경을 제공해야 합니다(네트워크 불안정, 클라이언트 재시작 등).
  - 이때, “세션”으로 볼 수 있는 사용자 정보를 **짧은 시간** 동안 유지하거나, 별도의 세션/토큰을 통해 연결 상태를 빠르게 복원할 수 있도록 해야 합니다.
  - 결과적으로, **사용자 정보를 오래 유지**해야 하는 상황이 많아져 세션 관리 측면에서 부하가 커질 수 있습니다.
1. **동시 접속자(Concurrency) 문제**
  - 온라인 게임의 가장 큰 특징 중 하나는 **순간적으로 많은 사용자가 동시에 접속**한다는 점입니다(이벤트, 특정 시간대 등).
  - 세션을 통한 사용자 상태 유지에 매우 많은 읽기·쓰기가 몰릴 수 있어, 세션 관리가 병목(Bottleneck)이 될 가능성이 큽니다.
---

## 3. 어느 레이어(Layer)에서 과부하가 주로 발생하는가?

> 아! 이래서 뒷단을 보라고 한거구나!

1. **애플리케이션 레이어(Application Layer)**
  - 웹 서버나 게임 서버 같은 **비즈니스 로직**이 동작하는 레이어에서, **세션을 생성/확인/갱신**하는 로직이 수행됩니다.
  - 세션 정보를 불러오거나 수정하는 과정이 빈번할수록, 서버 CPU와 메모리에 부담이 가중됩니다.
  - 동시에 많은 사용자 세션에 대해 로직이 수행되면 애플리케이션 레이어 자체가 **높은 부하**를 겪을 수 있습니다.
1. **데이터 레이어(Data Layer)**
  - 세션을 외부 스토어(예: Redis, DB)에 저장하는 경우, **세션 읽기/쓰기에 대한 트래픽**이 데이터 레이어에 집중됩니다.
  - 특히 Redis나 DB로 세션을 분산시킨 경우에도, **대규모 사용자 동시 요청**이 있을 때 I/O(입출력) 과부하가 발생할 수 있습니다.
  - 이로 인해 데이터 레이어의 **네트워크 트래픽**과 **처리량**이 급증하여 병목 지점이 될 수 있습니다.
---

## 4. 요약

- 세션이 과부하를 일으키는 가장 큰 이유는 **사용자별로 상태를 관리**해야 하고, 이 정보가 **지속적·빈번히 갱신**되기 때문입니다.
- 온라인 게임과 세션 유지가 밀접한 이유는, **실시간으로 변하는 사용자 상태**와 **동시 접속자 수**가 일반 웹 서비스보다 훨씬 많고 복잡하기 때문입니다.
- 이러한 세션 관련 과부하는 주로 **애플리케이션 레이어**와 **데이터 레이어**에서 나타나며, 세션 동기화나 대규모 읽기·쓰기, 메모리 사용량 증가가 병목으로 작용합니다.
결국, 세션을 효율적으로 관리하기 위해서는 **부하 분산(Load Balancing)**, **세션 스케일링(예: Redis 클러스터링)**, 그리고 **성능 모니터링** 등 다양한 최적화 기법이 필요합니다.

---

