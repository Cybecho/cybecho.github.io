---
title: "Let’s Bootc! [2] - What is OCI?"
date: 2026-01-25T06:50:00.000Z
draft: false
tags: ["Docker", "Infra"]
series: ["Meet The Bootc"]
description: "OCI는 컨테이너 생태계의 표준화를 위해 설립되었으며, bootc는 OCI 이미지를 사용하여 부팅 가능한 컨테이너를 생성합니다. bootc는 기존의 컨테이너 도구와 레지스트리를 활용할 수 있으며, 커널과 initramfs를 포함하여 실제 하드웨어에서 부팅할 수 있는 구조를 가지고 있습니다. 이로 인해 컨테이너 이미지가 운영 체제로서 기능할 수 있게 됩니다."
notion_id: "2f31bab9-e3f8-8091-a5d0-fb9961b84981"
notion_url: "https://www.notion.so/Let-s-Bootc-2-What-is-OCI-2f31bab9e3f88091a5d0fb9961b84981"
---

# Let’s Bootc! [2] - What is OCI?

> **Summary**
> OCI는 컨테이너 생태계의 표준화를 위해 설립되었으며, bootc는 OCI 이미지를 사용하여 부팅 가능한 컨테이너를 생성합니다. bootc는 기존의 컨테이너 도구와 레지스트리를 활용할 수 있으며, 커널과 initramfs를 포함하여 실제 하드웨어에서 부팅할 수 있는 구조를 가지고 있습니다. 이로 인해 컨테이너 이미지가 운영 체제로서 기능할 수 있게 됩니다.

---


![Image](image_43fa8dccc678.png)

![Image](image_a249b3d8fcfd.png)

## [2] OCI 표준과 bootc: 컨테이너가 OS가 되기까지

### 컨테이너가 부팅이 된다고?

퀵스타트를 따라 bootc 이미지를 빌드하고 부팅해본 분이라면 한 번쯤 이런 생각이 들었을 것입니다. "이거 그냥 Docker 이미지 아닌가? 근데 왜 부팅이 되지?”

Bootc에서는 Containerfile을 작성하고, `podman build`로 빌드하고, 레지스트리에 푸시하는 과정이 일반 컨테이너 이미지를 만드는 것과 다를 바 없었기 때문입니다. 그런데 이 이미지가 실제 하드웨어에서 부팅됩니다. 무엇이 다른거길래?

일단, 이 질문에 답하려면 먼저 OCI가 무엇인지부터 이해해야 합니다.

---

### OCI가 필요했던 이유

OCI는 Open Container Initiative의 약자입니다. 

2013년 Docker의 등장 이후 컨테이너 기술이 급속히 확산되었으나, 확산 속도 대비 표준이 부재하였고, Docker가 런타임과 이미지 포맷에 사실상 독점하고 있었습니다.

이로 인해 컨테이너 생태계 전체가 단일 기업의 구현에 종속되는 구조가 형성되었고, 업계에서는 이를 생태계 파편화와 벤더 종속의 위험 요소로 인식하였습니다.

그래서 2015년 6월, Docker와 CoreOS를 비롯한 컨테이너 업계 리더들이 Linux Foundation 산하에 설립한 프로젝트입니다. 이 프로젝트의 목적은 컨테이너 포맷과 런타임에 대한 개방형 산업 표준을 만드는 것이었습니다.

![Image](image_6b8454e73cd3.png)


그렇다면, 이 컨테이너에 대한 표준은 왜 필요했을까요?

가상화 기술의 역사를 돌아보면 답이 보입니다. VMware라던가 VirtualBox, KVM, Hyper-V 등 만드는 회사별로, 돌아가는 OS 시스템별로 많은 하이퍼바이저들이 있지 않습니까?

이들이 가상 머신을 만든다는 공통점은 있지만, VMware에서 만든 가상화 이미지가 Hyper-V에서 돌아가지 않듯이 서로 호환되지 않는다는 문제가 있었습니다. 각자의 포맷과 방식이 있었는데, 이는 결국 이전 VM 하이퍼바이저에는 표준이 없었다는 것이죠.

그렇다면 만약, 만약 컨테이너 생태계가 이런 식으로 파편화되었다면 어땠을까요? Docker에서 만든 이미지는 Docker에서만, Podman에서 만든 이미지는 Podman에서만 돌아가는 세상이었을 것입니다.

OCI는 이런 파편화를 막기 위해 탄생했습니다. 웹 기술에서 HTML, CSS, JavaScript가 브라우저에 관계없이 동작하는 것처럼, 컨테이너도 도구에 관계없이 동일하게 동작해야 한다는 철학으로 OCI는 탄생되었습니다.

![Image](image_6a9df1552fb5.png)

---

### OCI가 정의하는 세 가지

OCI는 현재 세 가지 스펙을 정의하고 있습니다.

첫째, **Image Specification**입니다. 컨테이너 이미지의 포맷을 정의합니다. 이미지가 어떤 구조를 가져야 하는지, 매니페스트와 레이어는 어떻게 구성되어야 하는지를 명시합니다.

둘째, **Runtime Specification**입니다. "파일시스템 번들"을 어떻게 실행할 것인지를 정의합니다. OCI 이미지를 다운로드하면 이를 언팩해서 런타임 번들로 만들고, 이 번들을 실행하는 방식을 표준화한 것입니다. runc가 이 스펙의 참조 구현체입니다.

셋째, **Distribution Specification**입니다. 컨테이너 이미지를 어떻게 배포할 것인지에 대한 API 프로토콜을 정의합니다. 레지스트리에 이미지를 푸시하고 풀하는 표준 API입니다.

이 세 가지가 맞물려 돌아갑니다. 이미지 스펙으로 이미지를 만들고, 배포 스펙으로 레지스트리에 올리고, 런타임 스펙으로 실행합니다. 그리고 이 모든 과정에서 어떤 도구를 쓰든 상관없습니다. 표준을 따르기만 하면 됩니다.

![Image](image_11ff71862394.png)

---

### 표준이 가져다준 것

이 표준 덕분에 우리는 Docker Hub에서 받은 이미지를 Podman으로 실행할 수 있습니다. containerd에서 빌드한 이미지를 CRI-O에서 돌릴 수 있습니다. 쿠버네티스가 다양한 컨테이너 런타임을 지원할 수 있는 것도 이 표준 덕분입니다.

![Image](image_4e321608a3fe.png)


레지스트리도 마찬가지입니다. Docker Hub, GitHub Container Registry, Quay.io, Harbor. 이들은 모두 OCI Distribution Specification을 따릅니다. 그래서 같은 명령어로 이미지를 푸시하고 풀할 수 있습니다. `podman push`든 `docker push`든 대상 레지스트리가 달라도 동작합니다.

해당 내용에 대해서는, 흐름이 잘 정리가 된 블로그 글이 있어, 아래 블로그 글을 참고해주시면 이해에 더 큰 도움이 되지 않을까 싶습니다.

🔗 [https://m.blog.naver.com/PostView.naver?blogId=pjt3591oo&logNo=222992244712&proxyReferer=&noTrackingCode=true](https://m.blog.naver.com/PostView.naver?blogId=pjt3591oo&logNo=222992244712&proxyReferer=&noTrackingCode=true)


---

### bootc가 OCI를 따른다는 것의 의미

bootc 공식 문서에는 이런 문장이 있습니다.

> "transactional, in-place operating system updates using OCI/Docker container images". 

OCI 컨테이너 이미지를 사용해서 운영체제를 업데이트한다는 뜻입니다.

이게 무슨 의미일까요.

- 첫째, 기존 컨테이너 도구를 그대로 쓸 수 있습니다. Podman이든 Docker든, OCI 이미지를 만들 수 있는 도구라면 무엇이든 bootc 이미지를 빌드할 수 있습니다. 새로운 도구를 배울 필요가 없습니다.
- 둘째, 기존 레지스트리 인프라를 그대로 쓸 수 있습니다. Docker Hub에 이미지를 올려도 되고, GHCR을 써도 되고, 회사 내부의 Harbor를 써도 됩니다. OCI Distribution Specification을 따르는 레지스트리라면 어디든 상관없습니다.
- 셋째, 이미지 레이어 구조를 그대로 활용합니다. OCI 이미지는 레이어로 구성됩니다. 베이스 이미지 위에 변경 사항을 레이어로 쌓아 올리는 구조입니다. bootc도 이 구조를 그대로 사용합니다. 업데이트할 때 변경된 레이어만 받으면 됩니다. 전체 OS 이미지를 매번 다시 받을 필요가 없습니다.
![Image](image_61f738b298dc.png)

Red Hat 문서에서도 이 점을 설명하고 있습니다. "rhel-10-bootc 컨테이너 이미지는 OCI 이미지 형식을 재사용합니다." 즉, 새로운 형식을 만든 게 아니라, rhel역시 기존 형식을 그대로 가져다 쓴 것이라는 것이죠.


---

### 그런데 일반 컨테이너와 뭐가 다른가

Bootable Container를 구글에 검색하면 상위에 보이는 이미지가 있습니다.

바로 아래 그림인데요, 일반 컨테이너와, bootc 컨테이너의 구조에 대해 설명하는 그림입니다.

![Image](image_d356a33a06f7.png)

왼쪽에는 App 두 개와 Base Image가 쌓여 있고, 오른쪽에는 같은 구성에 Linux Kernel이 하나 더 올라가 있습니다. 레이어 하나만 추가하면 부팅이 가능해진다는 걸 보여주려 했겠지만, 저는 처음 이 그림을 봤을 때 "그래서 뭐 어쩌라고?"라는 생각이 들었습니다.

하지만 이 단순한 그림은, 일반 컨테이너가 호스트의 커널을 공유하는 개념이라면, "아예 컨테이너 자체에 커널까지 포함해버리면 되는 거 아님?"이라는 부팅가능한(bootable) 컨테이너의 발칙한 아이디어를 표현한 것이지요.

일반 컨테이너는 호스트 OS의 커널을 빌려 씁니다. 컨테이너 안에서 `uname -r`을 실행하면 호스트의 커널 버전이 나옵니다. CentOS 컨테이너를 Windows 호스트에서 실행할 때는 사실 상황이 다릅니다. Docker Desktop은 WSL 2나 Hyper-V를 통해 내부적으로 Linux VM(또는 경량 Linux 커널)을 실행하고, 그 위에서 Linux 컨테이너를 구동합니다. 즉, Windows 커널이 직접 Linux 컨테이너를 실행하는 것이 아니라, 중간에 Linux 커널이 존재합니다.

반면 순수 Linux 환경에서는 호스트 커널을 직접 공유합니다. 컨테이너 안에서 `uname -r`을 실행하면 호스트(또는 WSL 2의 경우 Microsoft가 제공하는 Linux 커널)의 버전이 나옵니다.([관련 글](https://cybecho.github.io/posts/docker-%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-ubuntu-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%8A%94-%EC%82%AC%EC%8B%A4-ubuntu%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC%EA%B3%A0_-%EC%9D%B4%EA%B2%8C-%EB%AC%B4%EC%8A%A8%EB%A7%90%EC%9D%B8%EA%B2%83%EC%9D%B4%EB%9D%BC_/))

리눅스 커널의 namespace와 cgroups가 이 격리를 담당합니다. namespace는 프로세스에게 독립적인 PID, 네트워크, 파일시스템 뷰를 제공하고, cgroups는 CPU나 메모리 같은 자원 사용을 제한합니다. 격리는 확실하지만, 이 모든 것이 호스트 커널 위에서 일어납니다.

컨테이너는 별도 커널을 갖지 않고 호스트 커널을 공유합니다. 따라서 호스트(커널) 관점에서 컨테이너는 namespace/cgroup 및 보안 정책(capabilities/seccomp/LSM 등)이 적용된 프로세스 집합이며, 커널이 처리하는 것은 결국 그 프로세스들의 시스템 호출입니다.

그래서 일반 컨테이너 이미지의 `/boot` 디렉토리는 비어 있습니다. 커널도 없고, initramfs도 없습니다. 있을 필요가 없기 때문입니다. 호스트가 이미 커널을 제공하고 있으니까요.

![Image](image_99fc2e7a5c8d.png)

허나, bootc 이미지는 다릅니다. 그림의 오른쪽처럼, Linux Kernel이 이미지 안에 들어 있습니다. 정확히 말하면 `/usr/lib/modules/$kver/vmlinuz`에 커널이, 같은 디렉토리의 `initramfs.img`에 초기 램디스크가 위치합니다. 이 파일들이 이미지의 일부로 포함됩니다.

Red Hat 문서에서도 이 차이를 설명하고 있습니다.

"RHEL bootc 이미지는 기존의 애플리케이션 UBI와 다르며, 부팅에 필요한 추가 구성 요소를 포함합니다. kernel, initrd, boot loader, firmware 등이 그것입니다."

![Image](image_70d7c740d45a.png)

---

### 베이스 이미지의 역할

자, 그럼 QuickStarter로 돌아가, Containerfile의 첫 줄을 다시 보겠습니다.

```docker
FROM quay.io/centos-bootc/centos-bootc:stream10
```

이 한 줄이 일반 컨테이너 빌드와 bootc 빌드를 가르는 분기점입니다.

`centos-bootc:stream10` 같은 베이스 이미지에는 무엇이 들어 있을까요. bootc 문서에 따르면 최소한 다음이 포함되어야 합니다.

- **리눅스 커널 (**`**/usr/lib/modules/$kver/vmlinuz**`**)**
  - 하드웨어를 제어하고 프로세스 및 메모리를 관리하는 운영 체제의 핵심 실행 파일입니다.
- **initramfs (**`**/usr/lib/modules/$kver/initramfs.img**`**)**
  - 부팅 초기 단계에서 실제 루트 파일 시스템을 찾아 마운트하는 데 필요한 드라이버와 스크립트가 포함된 초기 램 디스크입니다.
- **부트로더 관련 설정 (bootupd가 관리)**
  - 시스템 전원을 켰을 때 커널을 메모리로 불러오는 프로그램(GRUB 등)을 설치하고 업데이트를 관리하는 구성 요소입니다.
- **OSTree 또는 composefs 구성** 
  - 컨테이너 이미지를 물리적 디스크에 배포하고, 이를 부팅 가능한 파일 시스템(주로 읽기 전용)으로 변환하여 관리하는 스토리지 백엔드 기술입니다.
- **SELinux 레이블 메타데이터**
  - 컨테이너 런타임(Podman 등) 없이 실제 OS로 부팅되었을 때, 파일 접근 권한과 보안 정책이 올바르게 작동하도록 미리 정의된 보안 레이블 정보입니다.
![Image](image_27fa3638d682.png)

여기서 OSTree가 등장합니다.

bootc는 OCI 이미지를 가져와서 OSTree 커밋으로 변환합니다. OSTree는 Git과 유사한 파일시스템 버전 관리 시스템인데, 이를 통해 원자적 업데이트와 롤백이 가능해집니다.

이러한 원자적 구성이 가능하기 위해서는, 베이스 이미지는 이 OSTree 구조를 미리 갖추고 있어야 합니다.

OSTree 구조에 대해서는 향후 글로 정리하도록 하겠습니다. 지금 당장은 git같은 무언가~ 정도로만 이해하셔도 괜찮습니다.

![Image](image_86d6b95f19a3.png)

이 시점에서, 그림을 다시 보면, 오른쪽 컨테이너의 Base Image 위에 Linux Kernel이 별도 레이어처럼 표현되어 있습니다. 실제로는 베이스 이미지 자체에 커널이 포함되어 있고, 우리가 그 위에 App을 올리는 구조입니다. 그림이 약간 단순화된 셈이지만, 핵심은 맞습니다. 베이스 이미지가 부팅의 기반을 제공한다는 것이지요!

bootc 문서는 이렇게 강조합니다. ["이 특별히 포맷된 베이스 이미지로부터, 컨테이너 빌드를 위한 모든 도구와 기법이 적용됩니다!"](https://bootc-dev.github.io/bootc/bootc-images.html) 베이스 이미지만 제대로 된 것을 쓰면 나머지는 일반 컨테이너 빌드와 똑같습니다. `RUN dnf install`도 되고, `COPY`도 되고, 멀티스테이지 빌드도 됩니다.

부팅된 시스템은 부트로더에서 커널로, 커널에서 initramfs로, 그리고 systemd로 이어지는 전통적인 리눅스 부팅 시퀀스를 따릅니다.

![Image](image_c70560e33e22.png)


---

### 왜 일반 컨테이너는 부팅이 안 되는가

이제 처음 질문에 답할 수 있습니다.

컴퓨터가 켜지면 무슨 일이 일어날까요. BIOS나 UEFI가 부트로더를 찾습니다. 부트로더가 커널을 메모리에 올립니다. 커널이 initramfs를 풀어서 초기 환경을 구성하고, 루트 파일시스템을 마운트합니다. 그제서야 init 프로세스(보통 systemd)가 시작됩니다.

이 과정에서 커널은 필수입니다. 커널 없이는 아무것도 시작되지 않습니다.

일반 Debian 컨테이너 이미지를 예로 들어보겠습니다. 컨테이너 내부에서 `tree -L 1 /boot`를 실행하면 빈 디렉토리가 나옵니다. 부팅 파일자체가 없습니다. 리눅스에서 모든 것은 파일입니다. 부팅에 필요한 커널 파일 자체가 없으니, 이 상태로는 절대 부팅할 수 없습니다. 부트로더가 로드할 커널 자체가 존재하지 않으니까요.

여기에 `linux-image-amd64` 패키지를 설치하면 약 230MB가 추가됩니다. `/boot/vmlinuz-*`에 커널이 들어가고, `/boot/initrd.img-*`에 initramfs가 들어가고, `/lib/modules`에 커널 모듈들이 들어갑니다. 그제서야 부팅의 기본 조건이 갖춰집니다.

bootc 베이스 이미지는 이 과정을 이미 거친 상태로 제공됩니다. 그래서 우리가 그 위에 KDE를 올리든, 서버용 최소 구성을 하든, 결과물은 부팅 가능합니다.

![Image](image_aff1d9cc9ab5.png)

### bootc install의 역할

하지만 커널이 있다고 바로 부팅되는 건 아닙니다. 실제 디스크에 설치하려면 파티셔닝, 부트로더 설치, 루트 파일시스템 배치가 필요합니다. `bootc install` 명령이 이 과정을 담당합니다. 

bootc 문서는 이렇게 설명합니다. 

"bootc install 명령은 표준적이고 실행 가능한 OCI 이미지와 부팅 가능한 시스템이라는 두 세계를 연결합니다."

그래서 bootc 이미지는 두 가지 모드로 동작할 수 있습니다. 

하나는 일반 컨테이너로 실행되는 모드입니다. 이때는 호스트 커널을 쓰고, namespace와 cgroups로 격리됩니다. 이미지 안의 커널은 그냥 파일로 존재할 뿐, 실행되지 않습니다. 

다른 하나는 실제 하드웨어나 VM에서 부팅되는 모드입니다. 이때 비로소 이미지 안의 커널이 사용됩니다.

이제 앞서 일반 컨테이너와 부팅 가능한 컨테이너에 대해서 개념이 명확해졌을 것입니다.

이 두 모드를 가르는 차이는, 레이어 하나의 차이뿐 만 아니라, 호스트에 의존하는 게스트와, 스스로 부팅할 수 있는 독립적인 시스템의 차이라고 생각하시면 좋을 듯 합니다.

> Summary
> - **컨테이너 모드**는 이미지 빌드, 테스트, CI/CD 파이프라인에서 패키지 설치나 설정이 제대로 되었는지 검증할 때 사용합니다.
> - **부팅 모드**는 검증된 이미지를 실제 서버나 VM에 운영체제로 배포할 때 사용합니다.
>

![Image](image_df15f20a39f7.png)

---

### 정리하면

OCI 표준 덕분에 bootc는 기존 컨테이너 생태계의 모든 것을 그대로 활용할 수 있습니다. 빌드 도구, 레지스트리, 레이어 구조, 이미지 배포 방식. 새로운 인프라를 구축할 필요가 없습니다.

bootc 이미지가 일반 컨테이너와 다른 점은 딱 하나입니다. 커널과 initramfs가 포함되어 있다는 것. 그리고 이것을 실제 디스크에 설치하는 도구(`bootc install`)가 함께 제공된다는 것.

"컨테이너 이미지가 곧 OS"라는 말의 의미가 이제 조금 명확해졌을 것입니다. OCI라는 표준 위에, 커널이라는 한 가지 요소를 더해서, 부팅 가능한 컨테이너라는 개념을 구현한 것이지요.

다음 글에서는 이 이미지가 실제로 디스크에 배치될 때 어떤 파일시스템 구조를 갖게 되는지 살펴보겠습니다. `/usr`는 왜 불변이고, `/etc`는 왜 3-way merge가 적용되며, `/var`는 왜 가변인지. 이 구조를 이해해야 Containerfile을 제대로 작성할 수 있습니다.

![Image](image_ed46d955b886.png)

# Reference 

[https://blog.naver.com/pjt3591oo/222992244712](https://blog.naver.com/pjt3591oo/222992244712)

