<!-- URL Preview Component -->
<div id="url-preview-styles">
<style>
/* URL Preview Card Styles */
.link-preview-card {
  display: flex;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  overflow: hidden;
  margin: 1.5rem 0;
  background: var(--secondary-bg);
  transition: all 0.2s ease;
  cursor: pointer;
  text-decoration: none;
  color: inherit;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
  height: auto;
  min-height: 100px;
}

.link-preview-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0,0,0,0.15);
  border-color: var(--primary-color);
}

.link-preview-card.loading {
  opacity: 0.7;
  pointer-events: none;
}

.preview-image-container {
  width: 140px;
  height: 100px;
  flex-shrink: 0;
  background: var(--tertiary-bg);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
}

.preview-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: center;
}

.preview-image-placeholder {
  color: var(--text-color-secondary);
  font-size: 2.5rem;
}

.preview-content {
  padding: 1rem;
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  min-width: 0;
  min-height: 98px; /* 이미지 컨테이너와 높이 맞춤 */
}

.preview-title {
  font-size: 1.05rem;
  font-weight: 600;
  color: var(--text-color);
  margin: 0 0 0.4rem 0;
  line-height: 1.25;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
  text-overflow: ellipsis;
}

.preview-description {
  font-size: 0.85rem;
  color: var(--text-color-secondary);
  line-height: 1.35;
  margin: 0 0 0.5rem 0;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
}

.preview-footer {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.preview-favicon {
  width: 16px;
  height: 16px;
  object-fit: contain;
  border-radius: 2px;
}

.preview-domain {
  font-size: 0.8rem;
  color: var(--primary-color);
  font-weight: 500;
}

.preview-loading {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 1rem;
  color: var(--text-color-secondary);
  font-size: 0.9rem;
}

.preview-loading-spinner {
  width: 16px;
  height: 16px;
  border: 2px solid var(--border-color);
  border-top: 2px solid var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.preview-error {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 1rem;
  color: var(--text-color-secondary);
  font-size: 0.9rem;
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  margin: 1rem 0;
}

.preview-error-icon {
  color: #ef4444;
}

/* 모바일 반응형 */
@media (max-width: 640px) {
  .link-preview-card {
    flex-direction: column;
    min-height: auto;
  }
  
  .preview-image-container {
    width: 100%;
    height: 140px;
  }
  
  .preview-content {
    padding: 1rem;
    min-height: auto;
  }
  
  .preview-title {
    font-size: 1rem;
    margin: 0 0 0.5rem 0;
  }
  
  .preview-description {
    font-size: 0.875rem;
    -webkit-line-clamp: 2;
    margin: 0 0 0.75rem 0;
  }
}

/* 다크모드에서 이미지 밝기 조절 */
@media (prefers-color-scheme: dark) {
  .preview-image {
    opacity: 0.9;
  }
  
  .link-preview-card:hover {
    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
  }
}

/* 접근성 향상 */
.link-preview-card:focus {
  outline: 2px solid var(--primary-color);
  outline-offset: 2px;
}

.link-preview-card[aria-label] {
  position: relative;
}

/* 링크 아이콘 */
.preview-external-icon {
  width: 12px;
  height: 12px;
  opacity: 0.6;
  margin-left: auto;
}
</style>
</div>

<script>
class URLPreview {
  constructor() {
    this.cache = new Map();
    this.corsProxies = [
      'https://api.codetabs.com/v1/proxy?quest=',
      'https://corsproxy.io/?',
      'https://cors-anywhere.herokuapp.com/'
    ];
    this.currentProxyIndex = 0;
    this.processedLinks = new Set();
    this.config = window.URLPreviewConfig || {};
    this.debounceTimer = null;
  }

  // 메인 초기화 함수
  async init() {
    // Intersection Observer 설정 (지연 로딩)
    this.setupIntersectionObserver();
    
    // DOM이 로드된 후 실행
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this.processAllLinks());
    } else {
      this.processAllLinks();
    }
    
    // 동적으로 추가되는 콘텐츠 감지
    this.observeContentChanges();
  }

  // Intersection Observer 설정
  setupIntersectionObserver() {
    this.intersectionObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const link = entry.target;
            this.intersectionObserver.unobserve(link);
            this.createPreviewCard(link);
          }
        });
      },
      {
        rootMargin: '100px 0px', // 뷰포트 100px 전에 미리 로드
        threshold: 0.1
      }
    );
  }

  // 모든 링크 처리
  processAllLinks() {
    // 디바운스 적용
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    
    this.debounceTimer = setTimeout(() => {
      const links = document.querySelectorAll('a[href^="http"]:not(.no-preview)');
      
      links.forEach(link => {
        if (!this.processedLinks.has(link.href) && this.shouldProcessLink(link)) {
          this.processedLinks.add(link.href);
          // Intersection Observer를 사용한 지연 로딩
          this.intersectionObserver.observe(link);
        }
      });
    }, this.config.debounceTime || 300);
  }

  // 링크 처리 여부 판단
  shouldProcessLink(link) {
    const url = link.href;
    
    // 외부 링크인지 확인
    if (!this.isExternalLink(url)) {
      return false;
    }
    
    // 제외 도메인 확인
    if (this.config.excludeDomains) {
      const domain = new URL(url).hostname;
      if (this.config.excludeDomains.some(excludeDomain => domain.includes(excludeDomain))) {
        return false;
      }
    }
    
    // 제외 선택자 확인
    if (this.config.excludeSelectors) {
      if (this.config.excludeSelectors.some(selector => link.matches(selector))) {
        return false;
      }
    }
    
    // 제외 패턴 확인
    if (this.config.excludePatterns) {
      if (this.config.excludePatterns.some(pattern => pattern.test(url))) {
        return false;
      }
    }
    
    return true;
  }

  // 외부 링크 판별
  isExternalLink(url) {
    try {
      const linkDomain = new URL(url).hostname;
      const currentDomain = window.location.hostname;
      return linkDomain !== currentDomain;
    } catch {
      return false;
    }
  }

  // 동적 콘텐츠 변경 감지
  observeContentChanges() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach(mutation => {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === 1) { // Element node
              const newLinks = node.querySelectorAll?.('a[href^="http"]:not(.no-preview)') || [];
              newLinks.forEach(link => {
                if (!this.processedLinks.has(link.href) && this.isExternalLink(link.href)) {
                  this.processedLinks.add(link.href);
                  this.createPreviewCard(link);
                }
              });
            }
          });
        }
      });
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }

  // 프리뷰 카드 생성
  async createPreviewCard(linkElement) {
    const url = linkElement.href;
    const loadingCard = this.createLoadingCard(url);
    
    // 링크를 로딩 카드로 교체
    linkElement.parentNode.replaceChild(loadingCard, linkElement);

    try {
      const metadata = await this.fetchUrlMetadata(url);
      const previewCard = this.buildPreviewCard(metadata, url);
      loadingCard.replaceWith(previewCard);
    } catch (error) {
      console.warn('URL preview failed:', error);
      const errorCard = this.createErrorCard(url, error.message);
      loadingCard.replaceWith(errorCard);
    }
  }

  // 로딩 카드 생성
  createLoadingCard(url) {
    const card = document.createElement('div');
    card.className = 'link-preview-card loading';
    card.innerHTML = `
      <div class="preview-loading">
        <div class="preview-loading-spinner"></div>
        <span>링크 정보를 가져오는 중...</span>
      </div>
    `;
    return card;
  }

  // 에러 카드 생성
  createErrorCard(url, errorMessage) {
    const domain = new URL(url).hostname;
    const card = document.createElement('a');
    card.className = 'preview-error';
    card.href = url;
    card.target = '_blank';
    card.rel = 'noopener noreferrer';
    card.innerHTML = `
      <span class="preview-error-icon">⚠️</span>
      <div>
        <div>프리뷰를 불러올 수 없습니다</div>
        <div style="font-size: 0.8rem; opacity: 0.7;">${domain}</div>
      </div>
    `;
    return card;
  }

  // URL 메타데이터 가져오기
  async fetchUrlMetadata(url) {
    // 캐시 확인
    if (this.cache.has(url)) {
      const cached = this.cache.get(url);
      if (Date.now() - cached.timestamp < (this.config.cache?.maxAge || 3600000)) {
        return cached.data;
      } else {
        this.cache.delete(url);
      }
    }

    const metadata = await this.fetchWithFallback(url);
    
    // 캐시 크기 관리
    const maxSize = this.config.cache?.maxSize || 100;
    if (this.cache.size >= maxSize) {
      // 가장 오래된 항목 제거 (LRU)
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    // 캐시 저장 (타임스탬프와 함께)
    this.cache.set(url, {
      data: metadata,
      timestamp: Date.now()
    });

    return metadata;
  }

  // 프록시 폴백으로 데이터 가져오기
  async fetchWithFallback(url) {
    const timeout = this.config.timeout || 10000;
    
    for (let i = 0; i < this.corsProxies.length; i++) {
      try {
        const proxyIndex = (this.currentProxyIndex + i) % this.corsProxies.length;
        const proxyUrl = this.corsProxies[proxyIndex] + encodeURIComponent(url);
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const response = await fetch(proxyUrl, {
          method: 'GET',
          headers: {
            'User-Agent': 'Mozilla/5.0 (compatible; URLPreview/1.0)'
          },
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const html = await response.text();
        const metadata = this.extractMetadata(html, url);
        
        // 성공한 프록시를 우선순위로 설정
        this.currentProxyIndex = proxyIndex;
        return metadata;
      } catch (error) {
        console.warn(`Proxy ${i + 1} failed:`, error.message);
        if (i === this.corsProxies.length - 1) {
          throw new Error('모든 프록시 서버에서 실패했습니다');
        }
      }
    }
  }

  // HTML에서 메타데이터 추출
  extractMetadata(html, url) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const urlObj = new URL(url);

    // Open Graph 메타태그 우선
    const getMetaContent = (property) => {
      const og = doc.querySelector(`meta[property="${property}"]`);
      const twitter = doc.querySelector(`meta[name="twitter:${property.replace('og:', '')}"]`);
      const name = doc.querySelector(`meta[name="${property.replace('og:', '')}"]`);
      
      return og?.content || twitter?.content || name?.content || '';
    };

    // 제목 추출
    let title = getMetaContent('og:title') || 
                getMetaContent('twitter:title') || 
                doc.querySelector('title')?.textContent || 
                urlObj.hostname;

    // 설명 추출  
    let description = getMetaContent('og:description') || 
                     getMetaContent('description') ||
                     getMetaContent('twitter:description') || '';

    // 이미지 추출
    let image = getMetaContent('og:image') || 
                getMetaContent('twitter:image') || '';

    // 상대 URL을 절대 URL로 변환
    if (image && !image.startsWith('http')) {
      try {
        image = new URL(image, url).href;
      } catch {
        image = '';
      }
    }

    // 파비콘 추출
    let favicon = doc.querySelector('link[rel*="icon"]')?.href || '';
    if (favicon && !favicon.startsWith('http')) {
      try {
        favicon = new URL(favicon, url).href;
      } catch {
        favicon = `${urlObj.protocol}//${urlObj.hostname}/favicon.ico`;
      }
    }

    return {
      title: title.trim().substring(0, 100),
      description: description.trim().substring(0, 200),
      image: image,
      favicon: favicon,
      domain: urlObj.hostname,
      url: url
    };
  }

  // 프리뷰 카드 생성
  buildPreviewCard(metadata, url) {
    const card = document.createElement('a');
    card.className = 'link-preview-card';
    card.href = url;
    card.target = '_blank';
    card.rel = 'noopener noreferrer';
    card.setAttribute('aria-label', `외부 링크: ${metadata.title}`);

    // 도메인별 아이콘 설정
    const domain = metadata.domain;
    const fallbackIcon = this.config.fallbackIcons?.[domain] || this.config.fallbackIcons?.['default'] || '🔗';
    
    let imageHTML = '';
    if (metadata.image) {
      imageHTML = `<img class="preview-image" src="${metadata.image}" alt="${metadata.title}" loading="lazy" onerror="this.parentElement.innerHTML='<span class=\\"preview-image-placeholder\\">${fallbackIcon}</span>'">`;
    } else {
      imageHTML = `<span class="preview-image-placeholder">${fallbackIcon}</span>`;
    }

    let faviconHTML = '';
    if (metadata.favicon) {
      faviconHTML = `<img class="preview-favicon" src="${metadata.favicon}" alt="" onerror="this.style.display='none'">`;
    }

    card.innerHTML = `
      <div class="preview-image-container">
        ${imageHTML}
      </div>
      <div class="preview-content">
        <h3 class="preview-title">${this.escapeHtml(metadata.title)}</h3>
        ${metadata.description ? `<p class="preview-description">${this.escapeHtml(metadata.description)}</p>` : ''}
        <div class="preview-footer">
          ${faviconHTML}
          <span class="preview-domain">${metadata.domain}</span>
          <svg class="preview-external-icon" fill="currentColor" viewBox="0 0 20 20">
            <path d="M11 3a1 1 0 100 2h2.586l-6.293 6.293a1 1 0 101.414 1.414L15 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1h-5z"></path>
            <path d="M5 5a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2v-2a1 1 0 10-2 0v2H5V7h2a1 1 0 000-2H5z"></path>
          </svg>
        </div>
      </div>
    `;

    return card;
  }

  // HTML 이스케이프
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

// URL 프리뷰 초기화
const urlPreview = new URLPreview();
urlPreview.init();

// 전역 함수로 노출 (필요시 사용)
window.URLPreview = URLPreview;
</script>